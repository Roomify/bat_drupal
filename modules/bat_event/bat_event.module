<?php

/**
 * @file
 * Manage Events - Events store the EventValue of a Unit over a period of time.
 */

use Roomify\Bat\Calendar\Calendar;
use Roomify\Bat\Store\DrupalDBStore;
use Roomify\Bat\Unit\Unit;

use Drupal\Core\Database\Query\AlterableInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\Core\Render\Element;
use Drupal\Core\Entity\Entity\EntityFormDisplay;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Component\Utility\SafeMarkup;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\views\ViewExecutable;
use Symfony\Component\HttpFoundation\JsonResponse;
use Drupal\bat_event\Entity\Event;
use Drupal\bat_event\Entity\EventType;
use Drupal\bat_event\Entity\State;

/**
 * Create a field of type 'Bat Event State Reference' to reference an Event State.
 */
function bat_event_type_add_event_state_reference($entity) {
  $field_name = 'event_state_reference';

  $field_storage = FieldStorageConfig::loadByName('bat_event', $field_name);
  $field = FieldConfig::loadByName('bat_event', $entity->id(), $field_name);

  if (empty($field_storage)) {
    $field_storage = FieldStorageConfig::create([
      'field_name' => $field_name,
      'entity_type' => 'bat_event',
      'type' => 'entity_reference',
      'cardinality' => 1,
      'locked' => 1,
      'settings' => array(
        'target_type' => 'state',
      ),
    ]);
    $field_storage->save();
  }

  if (empty($field)) {
    $field = FieldConfig::create([
      'field_storage' => $field_storage,
      'entity_type' => 'bat_event',
      'label' => 'State',
      'bundle' => $entity->id(),
      'required' => FALSE,
      'settings' => [
        'handler' => 'default',
        'handler_settings' => [],
      ],
    ]);
    $field->save();

    $form_display = \Drupal::entityTypeManager()->getStorage('entity_form_display')->load('bat_event.' . $entity->id() . '.default');
    if (!$form_display) {
      $form_display = EntityFormDisplay::create([
        'targetEntityType' => 'bat_event',
        'bundle' => $entity->id(),
        'mode' => 'default',
        'status' => TRUE,
      ]);
    }
    $form_display->setComponent($field_name, [
      'type' => 'entity_reference_autocomplete',
      'weight' => 3,
    ]);
    $form_display->save();
  }
}

/**
 * Create fields of type 'Entity Reference' to reference the target entity.
 *
 * We need to create a field/instance for each possible target entity type.
 */
function bat_event_type_add_target_entity_field($entity) {
  $entity_info = \Drupal::entityManager()->getDefinition($entity->target_entity_type);
  $field_name = 'event_' . $entity->target_entity_type . '_reference';

  $field_storage = FieldStorageConfig::loadByName('bat_event', $field_name);
  $field = FieldConfig::loadByName('bat_event', $entity->id(), $field_name);

  if (empty($field_storage)) {
    $field_storage = FieldStorageConfig::create([
      'field_name' => $field_name,
      'entity_type' => 'bat_event',
      'type' => 'entity_reference',
      'cardinality' => 1,
      'locked' => 1,
      'settings' => array(
        'target_type' => $entity->target_entity_type,
      ),
    ]);
    $field_storage->save();
  }

  if (empty($field)) {
    $field = FieldConfig::create([
      'field_storage' => $field_storage,
      'entity_type' => 'bat_event',
      'label' => $entity_info->getLabel()->__toString(),
      'bundle' => $entity->id(),
      'required' => FALSE,
      'settings' => [
        'handler' => 'default',
        'handler_settings' => [],
      ],
    ]);
    $field->save();

    $form_display = \Drupal::entityTypeManager()->getStorage('entity_form_display')->load('bat_event.' . $entity->id() . '.default');
    if (!$form_display) {
      $form_display = EntityFormDisplay::create([
        'targetEntityType' => 'bat_event',
        'bundle' => $entity->id(),
        'mode' => 'default',
        'status' => TRUE,
      ]);
    }
    $form_display->setComponent($field_name, [
      'type' => 'entity_reference_autocomplete',
      'weight' => 3,
    ]);
    $form_display->save();
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * FORM_ID = views_exposed_form
 */
function bat_event_form_views_exposed_form_alter(&$form, FormStateInterface $form_state) {
  // Events admin view exposed filters.
  if ($form['#id'] == 'views-exposed-form-events-page-1') {
    $date_format = \Drupal::config('bat.settings')->get('daily_date_format') ?: 'Y-m-d';

    $form['start_date']['#type'] = 'date_popup';
    $form['start_date']['#date_format'] = $date_format;
    $form['start_date']['#date_label_position'] = 'before';

    $form['end_date']['#type'] = 'date_popup';
    $form['end_date']['#date_format'] = $date_format;
    $form['end_date']['#date_label_position'] = 'before';

    $form['#attached']['css'][] = array(
      'data' => '.views-exposed-form .views-exposed-widget { height: 70px; }',
      'type' => 'inline',
    );
  }
}

/**
 * Checks event access for various operations.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param object $event
 *   Optionally an event to check access for.
 * @param object $account
 *   The user to check for. Leave it to NULL to check for the current user.
 *
 * @return bool
 *   Boolean indicating if the defined user has access to the event or not.
 */
function bat_event_access(EntityInterface $entity, $operation, AccountInterface $account) {
  return bat_entity_access($entity, $operation, $account);
}

/**
 * Access callback for the entity API.
 */
function bat_event_type_access(EntityInterface $entity, $operation, AccountInterface $account) {
  $account->hasPermission('administer bat_event_type entities');
}

/**
 * Implements hook_query_TAG_alter().
 */
function bat_event_query_bat_event_access_alter(AlterableInterface $query) {
  // Look for an event base table to pass to the query altering function or
  // else assume we don't have the tables we need to establish order related
  // altering right now.
  foreach ($query->getTables() as $table) {
    if ($table['table'] === 'event') {
      bat_entity_access_query_alter($query, 'bat_event', $table['alias']);
      break;
    }
  }
}

function bat_event_load_state($state_id) {
  return State::load($state_id);
}

/**
 * Helper function to easily get event types in an array for use in forms, etc.
 *
 * @return array
 *  An array of event types keyed by type id and labels
*/
function bat_event_types_ids() {
  $event_types = array();

  $types = bat_event_get_types();
  foreach ($types as $type) {
    $event_types[$type->id] = $type->label;
  }

  return $event_types;
}

/**
 * Gets an array of all event types, keyed by the type name.
 *
 * @param string $type_name
 *   If set, the type with the given name is returned.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return BatEventType[]
 *   Depending whether $type isset, an array of event types or a single one.
 */
function bat_event_get_types($type_name = NULL, $reset = FALSE) {
  $types = EventType::loadMultiple();
  return isset($type_name) ? $types[$type_name] : $types;
}

/**
 * Menu argument loader; Load a event type by string.
 *
 * @param string $type
 *   The machine-readable name of a event type to load.
 *
 * @return array|false
 *   An event type array or FALSE if $type does not exist.
 */
function bat_event_type_load($type) {
  return EventType::load($type);
}

/**
 * Fetches an event object.
 *
 * @param int $event_id
 *   Integer specifying the event id.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return object
 *   A fully-loaded $event object or FALSE if it cannot be loaded.
 *
 * @see bat_event_load_multiple()
 */
function bat_event_load($event_id = NULL, $reset = FALSE) {
  if ($reset) {
    \Drupal::entityManager()->getStorage('bat_event')->resetCache(array($nid));
  }
  return Event::load($event_id);
}

/**
 * Load multiple events based on certain conditions.
 *
 * @param array $event_ids
 *   An array of event IDs.
 * @param array $conditions
 *   An array of conditions to match against the {bat_events} table.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return array
 *   An array of event objects, indexed by event_id.
 *
 * @see entity_load()
 * @see bat_event_load()
 */
function bat_event_load_multiple(array $event_ids = NULL, $reset = FALSE) {
  if ($reset) {
    \Drupal::entityManager()->getStorage('bat_event')->resetCache($event_ids);
  }
  return Event::loadMultiple($event_ids);
}

/**
 * Deletes a event.
 *
 * @param BatEvent $event
 *   The BatEvent object that represents the event to delete
 */
function bat_event_delete(Event $event) {
  bat_event_delete_multiple(array($event->event_id));
}

/**
 * Delete multiple events.
 *
 * @param array $event_ids
 *   An array of event IDs.
 */
function bat_event_delete_multiple(array $event_ids) {
  
}

/**
 * Create a event object.
 */
function bat_event_create($values = array()) {
  return Event::create($values);
}

/**
 * Saves a event to the database.
 *
 * @param BatEvent $event
 *   The Event object.
 */
function bat_event_save(Event $event) {
  return $event->save();
}

/**
 * Create a event object.
 */
function bat_event_type_create($values = array()) {
  
}

/**
 * Saves a event type to the db.
 */
function bat_event_type_save(EventType $type) {
  $type->save();
}

/**
 * Deletes a event type from the db.
 */
function bat_event_type_delete(EventType $type) {
  
}

/**
 * URI callback for events.
 */
function bat_event_uri(Event $event) {
  return array(
    'path' => 'event/' . $event->event_id,
  );
}

/**
 * Menu title callback for showing individual entities.
 */
function bat_event_page_title(Event $event) {
  return '';
}

/**
 * Get a list of Event keyed by id and name in value.
 */
function bat_event_ids($conditions = array()) {
  $events = array();

  $query = new EntityFieldQuery();

  $result = $query->entityCondition('entity_type', 'bat_event')
                    ->execute();

  if (count($result) > 0) {
    $entities = bat_event_load_multiple(array_keys($result['bat_event']), $conditions);
    foreach ($entities as $event) {
      $wrapper = entity_metadata_wrapper('bat_event', $event);
      $events[$wrapper->event_id->value()] = $wrapper->name->value();
    }
  }

  return $events;
}

/**
 * Sets up content to show an individual event.
 */
function bat_event_page_view($event, $view_mode = 'full') {
  return $content;
}

/**
 * Implements hook_theme().
 */
function bat_event_theme() {
  return array(
    'bat_event' => array(
      'render element' => 'elements',
      'template' => 'bat_event',
    ),
    'bat_event_add_list' => array(
      'variables' => array('content' => NULL),
    ),
  );
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function bat_event_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link 'admin/bat/units/add' on 'admin/bat/units'.
  if ($root_path == 'admin/bat/events') {
    $item = menu_get_item('admin/bat/events/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * JSON output for autocomplete bat_event_types.
 *
 * @param string $bat_event_type_name
 *   The bat_event type seed to look for.
 */
function bat_event_get_unit_bundles($bat_event_type_name = '') {
  /*$matches = array();
  if ($bat_event_type_name) {
    $result = db_select('bat_event_type')
      ->fields('bat_event_type', array('type'))
      ->condition('type', db_like($bat_event_type_name) . '%', 'LIKE')
      ->range(0, 10)
      ->execute();
    foreach ($result as $unit_bundle) {
      $matches[$unit_bundle->type] = SafeMarkup::checkPlain($unit_bundle->type);
    }
  }

  return new JsonResponse ($matches);*/
}

/**
 * Menu callback for the autocomplete results.
 */
function bat_event_reference_autocomplete($entity_type, $bundle, $field_name, $string = '') {
  $field = FieldStorageConfig::loadByName($field_name);
  $instance = FieldConfig::loadByName($entity_type, $bundle, $field_name);

  $options = array(
    'string' => $string,
    'match' => $instance['widget']['settings']['autocomplete_match'],
    'limit' => 10,
    'event_type' => $instance['settings']['event_type'],
  );
  $references = bat_event_potential_references($field, $options);

  $matches = array();
  foreach ($references as $id => $row) {
    // Markup is fine in autocompletion results (might happen when rendered
    // through Views) but we want to remove hyperlinks.
    $suggestion = preg_replace('/<a href="([^<]*)">([^<]*)<\/a>/', '$2', $row['rendered']);
    // Add a class wrapper for a few required CSS overrides.
    $matches[$row['title'] . " [state_id:$id]"] = '<div class="reference-autocomplete">' . $suggestion . '</div>';
  }

  return new JsonResponse ($matches);
}

/**
 * Value callback for a bat_event_reference autocomplete element.
 */
function bat_event_autocomplete_value($element, $input = FALSE, $form_state) {
  if ($input === FALSE) {
    $state_id = $element['#default_value'];

    if (!empty($state_id)) {
      if ($state = bat_event_load_state($state_id)) {
        $value = $state['label'];
        $value .= ' [state_id:' . $state_id . ']';

        return $value;
      }
      else {
        return '';
      }
    }
  }
}

/**
 * Given an event machine name drop all the tables that store event data for that event.
 *
 * @param $machine_name
 */
function bat_event_delete_event_type_schema($machine_name) {
  foreach (bat_event_get_event_type_tables($machine_name) as $name) {
    db_drop_table($name);
  }
}

/**
 * Utility function to return the table names
 * required to start an event using BAT conventions.
 *
 * @param $machine_name
 */
function bat_event_get_event_type_tables($machine_name) {
  return array('bat_event_' . $machine_name . '_day_state',
               'bat_event_' . $machine_name . '_day_event',
               'bat_event_' . $machine_name . '_hour_state',
               'bat_event_' . $machine_name . '_hour_event',
               'bat_event_' . $machine_name . '_minute_state',
               'bat_event_' . $machine_name . '_minute_event');
}

/**
 * Create 6 tables for store events of type $machine_name.
 *
 * @param $machine_name
 */
function bat_event_create_event_type_schema($machine_name) {
  $schema = array();

  $schema['bat_event_' . $machine_name . '_day_state'] = array(
    'description' => 'Holds the state of each unit for a given day',
    'fields' => bat_event_generate_day_schema_fields(),
    'indexes' => array(
      'unit_id' => array('unit_id'),
      'year' => array('year'),
      'month' => array('month'),
    ),
    'unique keys' => array(
      'month_key' => array('unit_id', 'year', 'month'),
    ),
    'foreign keys' => array(
      'unit_id' => array(
        'table' => 'unit',
        'columns' => array('unit_id' => 'id'),
      ),
    ),
  );

  $schema['bat_event_' . $machine_name . '_day_event'] = array(
    'description' => 'Holds the event that determined the state of a unit',
    'fields' => bat_event_generate_day_schema_fields(),
    'indexes' => array(
      'unit_id' => array('unit_id'),
      'year' => array('year'),
      'month' => array('month'),
    ),
    'unique keys' => array(
      'month_key' => array('unit_id', 'year', 'month'),
    ),
    'foreign keys' => array(
      'unit_id' => array(
        'table' => 'unit',
        'columns' => array('unit_id' => 'id'),
      ),
    ),
  );

  $schema['bat_event_' . $machine_name . '_hour_state'] = array(
    'description' => 'Holds the state of the unit',
    'fields' => bat_event_generate_hour_schema_fields(),
    'indexes' => array(
      'unit_id' => array('unit_id'),
      'year' => array('year'),
      'month' => array('month'),
    ),
    'unique keys' => array(
      'day_key' => array('unit_id', 'year', 'month', 'day'),
    ),
    'foreign keys' => array(
      'unit_id' => array(
        'table' => 'unit',
        'columns' => array('unit_id' => 'id'),
      ),
    ),
  );

  $schema['bat_event_' . $machine_name . '_hour_event'] = array(
    'description' => 'Holds the event that determined the state of a unit',
    'fields' => bat_event_generate_hour_schema_fields(),
    'indexes' => array(
      'unit_id' => array('unit_id'),
      'year' => array('year'),
      'month' => array('month'),
    ),
    'unique keys' => array(
      'day_key' => array('unit_id', 'year', 'month', 'day'),
    ),
    'foreign keys' => array(
      'unit_id' => array(
        'table' => 'unit',
        'columns' => array('unit_id' => 'id'),
      ),
    ),
  );

  $schema['bat_event_' . $machine_name . '_minute_state'] = array(
    'description' => 'Holds the state of the unit',
    'fields' => bat_event_generate_minute_schema_fields(),
    'indexes' => array(
      'unit_id' => array('unit_id'),
      'year' => array('year'),
      'month' => array('month'),
    ),
    'unique keys' => array(
      'day_key' => array('unit_id', 'year', 'month', 'day', 'hour'),
    ),
    'foreign keys' => array(
      'unit_id' => array(
        'table' => 'unit',
        'columns' => array('unit_id' => 'id'),
      ),
    ),
  );

  $schema['bat_event_' . $machine_name . '_minute_event'] = array(
    'description' => 'Holds the event that determined the state of a unit',
    'fields' => bat_event_generate_minute_schema_fields(),
    'indexes' => array(
      'unit_id' => array('unit_id'),
      'year' => array('year'),
      'month' => array('month'),
    ),
    'unique keys' => array(
      'day_key' => array('unit_id', 'year', 'month', 'day', 'hour'),
    ),
    'foreign keys' => array(
      'unit_id' => array(
        'table' => 'unit',
        'columns' => array('unit_id' => 'id'),
      ),
    ),
  );

  foreach ($schema as $name => $table) {
    db_create_table($name, $table);
  }
}

/**
 * Creates the necessary day schema fields.
 *
 * @return array
 */
function bat_event_generate_day_schema_fields() {
  $fields = array(
      'unit_id' => array(
      'description' => 'Identifier for a unit.',
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
    ),
      'year' => array(
      'description' => 'The calendar year for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
      'month' => array(
      'description' => 'The month for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
  );

  for ($i = 1; $i <= 31; $i++) {
    $fields['d' . $i] = array(
      'description' => 'D' . $i,
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    );
  }

  return $fields;
}

/**
 * Creates the necessary hour schema fields.
 *
 * @return array
 */
function bat_event_generate_hour_schema_fields() {
  $fields = array(
    'unit_id' => array(
      'description' => 'Identifier for a unit.',
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
    ),
    'year' => array(
      'description' => 'The calendar year for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
    'month' => array(
      'description' => 'The month for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
    'day' => array(
      'description' => 'The day for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
  );

  for ($i = 0; $i <= 23; $i++) {
    $fields['h' . $i] = array(
      'description' => 'H' . $i,
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    );
  }

  return $fields;
}

/**
 * Creates the necessary minute schema fields.
 *
 * @return array
 */
function bat_event_generate_minute_schema_fields() {
  $fields = array(
    'unit_id' => array(
      'description' => 'Identifier for a unit.',
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
    ),
    'year' => array(
      'description' => 'The calendar year for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
    'month' => array(
      'description' => 'The month for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
    'day' => array(
      'description' => 'The day for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
    'hour' => array(
      'description' => 'The hour for which this availability row is relevant',
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    ),
  );

  for ($i = 0; $i <= 59; $i++) {
    // PHP has no clean way to get the minutes without leading zeros so setting table
    // fields names to contain the leading zeros to save strangeness in code elsewhere
    if ($i <= 9) { $m='0' . $i; } else { $m = $i; }

    $fields['m' . $m] = array(
      'description' => 'M' . $m,
      'type' => 'int',
      'not null' => TRUE,
      'default' => '0',
    );
  }

  return $fields;
}

/**
 * Utility function to validate hex color numbers.
 */
function bat_event_validate_hex_color($element, FormStateInterface $form_state) {
  if (!preg_match('/^#[a-f0-9]{6}$/i', $element['#value'])) {
    form_error($element, t('This is not a valid hexadecimal color!'));
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function bat_event_form_bat_type_bundle_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $type_bundle = $form_state->getFormObject()->getEntity();

  $fields_options = array();

  $fields = \Drupal::entityManager()->getFieldDefinitions('bat_unit_type', $type_bundle->id());
  foreach ($fields as $field) {
    if ($field instanceof FieldConfig) {
      $fields_options[$field->getName()] = $field->getLabel() . ' (' . $field->getName() . ')';
    }
  }

  $form['events'] = array(
    '#type' => 'details',
    '#group' => 'advanced',
    '#title' => t('Events'),
    '#tree' => TRUE,
    '#weight' => 80,
  );

  $event_types = bat_event_get_types();
  foreach ($event_types as $event_type) {
    $form['events'][$event_type->id()] = array(
      '#type' => 'select',
      '#title' => t('Select your default @event field', array('@event' => $event_type->label())),
      '#options' => $fields_options,
      '#default_value' => isset($type_bundle->default_event_value_field_ids[$event_type->id()]) ? $type_bundle->default_event_value_field_ids[$event_type->id()] : NULL,
      '#empty_option' => t('- Select a field -'),
    );
  }

  $form['actions']['submit']['#submit'][] = 'bat_event_form_bat_type_bundle_form_submit';
}

/**
 * Submit callback for bat_event_form_bat_type_bundle_form form.
 */
function bat_event_form_bat_type_bundle_form_submit($form, FormStateInterface $form_state) {
  $type_bundle = $form_state->getFormObject()->getEntity();

  foreach ($form_state->getValues()['events'] as $event => $field) {
    $type_bundle->default_event_value_field_ids[$event] = $field;
  }

  $type_bundle->save();
}

/**
 * Implements hook_views_pre_render().
 */
function bat_event_views_pre_render(ViewExecutable $view) {
  // Use "BAT PHP Date Format" for event Start date and End date.
  if (in_array('event', $view->getBaseTables())) {
    $date_format = \Drupal::config('bat.settings')->get('date_format') ?: 'Y-m-d H:i';

    if (isset($view->field['start_date']->options['custom_date_format'])) {
      $view->field['start_date']->options['custom_date_format'] = $date_format;
    }
    if (isset($view->field['end_date']->options['custom_date_format'])) {
      $view->field['end_date']->options['custom_date_format'] = $date_format;
    }
  }
}

/**
 * Given a date range and a set of valid states it will return all units within the
 * set of valid states.
 *
 * @param DateTime $start_date
 * @param DateTime $end_date
 * @param $valid_name_states
 * @param $type_id
 * @param $event_type
 * @param $intersect
 *
 * @return array|bool
 */
function bat_event_get_matching_units(DateTime $start_date, DateTime $end_date, $valid_name_states, $type_id, $event_type, $intersect = FALSE) {
  // Instantiate a BAT Calendar
  $calendar = bat_event_get_calendar($type_id, $event_type);

  return bat_event_get_matching_units_from_calendar($calendar, $start_date, $end_date, $valid_name_states, $intersect);
}

/**
 * Retrieves relevant units and instantiates a BAT calendar object than can be reused. It is preferred to
 * use this function to reduce the cost of setting up a calendar (i.e. loading units).
 *
 * @param $type_id
 * @param $event_type
 *
 * @return Calendar
 */
function bat_event_get_calendar($type_id, $event_type) {
  $database = Database::getConnectionInfo('default');

  $prefix = (isset($database['default']['prefix']['default'])) ? $database['default']['prefix']['default'] : '';

  $state_store = new DrupalDBStore($event_type, DrupalDBStore::BAT_STATE, $prefix);

  $drupal_units = bat_unit_load_multiple(FALSE, array('type_id' => $type_id));
  $bat_units = array();

  foreach ($drupal_units as $unit_id => $unit) {
    $bat_units[] = new Unit($unit_id, $unit->getEventDefaultValue($event_type));
  }

  $calendar = new Calendar($bat_units, $state_store);

  return $calendar;
}

/**
 * Returns matching units based on a provided Calendar. A Calendar can be instantiated in a numder
 * of ways - bat_event offers bat_event_get_calendar. Using an already setup calendar multiple times
 * reduces overall load.
 *
 * @param $calendar
 * @param DateTime $start_date
 * @param DateTime $end_date
 * @param $valid_name_states
 * @param $intersect
 * @param $reset
 *
 * @return array|bool
 */
function bat_event_get_matching_units_from_calendar($calendar, DateTime $start_date, DateTime $end_date, $valid_name_states, $intersect = FALSE, $reset = TRUE) {
  $valid_states = array();
  foreach ($valid_name_states as $name) {
    $valid_states[] = $state['id'];
  }

  $constraints = array();
  foreach (bat_event_constraints_get_info() as $constraint) {
    $constraints[] = $constraint['constraint'];
  }

  $response = $calendar->getMatchingUnits($start_date, $end_date, $valid_states, $constraints, $intersect, $reset);

  $valid_unit_ids = array_keys($response->getIncluded());

  if (count($valid_unit_ids)) {
    return $valid_unit_ids;
  }

  return FALSE;
}

/**
 * Given a date range and a set of valid states it will return all units within the
 * set of valid states.
 *
 * @param DateTime $start_date
 * @param DateTime $end_date
 * @param $valid_name_states
 * @param $type_id
 * @param $event_type
 * @param $intersect
 *
 * @return array
 */
function bat_event_get_calendar_response(DateTime $start_date, DateTime $end_date, $valid_name_states, $type_id, $event_type, $intersect = FALSE) {
  $results = array(
    'included' => array(),
    'excluded' => array(),
  );

  $calendar = bat_event_get_calendar($start_date, $end_date, $type_id, $event_type);

  $response = $calendar->getMatchingUnits($start_date, $end_date, $valid_states, $constraints, $intersect);

  $valid_unit_ids = array_keys($response->getIncluded());

  $excluded = array();
  foreach ($response->getExcluded() as $unit_id => $ex) {
    if (isset($ex['constraint'])) {
      $p = $ex['constraint']->toString();
      $excluded[$unit_id] = t($p['text'], $p['args']);
    }
    else {
      $excluded[$unit_id] = '';
    }
  }

  $results['excluded'] = $excluded;

  if (count($valid_unit_ids)) {
    $results['included'] = $valid_unit_ids;
  }

  return $results;
}

/**
 * @see hook_event_constraints_info()
 * @see hook_event_constraints_info_alter()
 */
function bat_event_constraints_get_info() {
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['bat_event_constraints_info'] = &drupal_static(__FUNCTION__);
  }
  $constraints_info = &$drupal_static_fast['bat_event_constraints_info'];

  if (empty($constraints_info)) {
    if ($cache = \Drupal::cache()->get('bat_event_constraints_info')) {
      $constraints_info = $cache->data;
    }
    else {
      $constraints_info = \Drupal::moduleHandler()->invokeAll('bat_event_constraints_info');

      // Let other modules alter the entity info.
      \Drupal::moduleHandler()->alter('bat_event_constraints_info', $constraints_info);
      \Drupal::cache()->get('bat_event_constraints_info', $constraints_info);
    }
  }

  return $constraints_info;
}

/**
 * Implements hook_action_info().
 */
function bat_event_action_info() {
  return array(
    'bat_event_unit_set_state' => array(
      'type' => 'bat_unit',
      'label' => t('Assign fixed-state event to units'),
      'behavior' => array('bat_event_unit_set_state'),
      'configurable' => TRUE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * VBO action: Assign fixed-state event to units.
 */
function bat_event_unit_set_state(&$unit, $context) {
  $type = bat_type_load($unit->type_id);
  $type_bundle = bat_type_bundle_load($type->type);

  $event_state = $context['form_values']['event_state'];
  $event_type = $context['form_values']['event_type'];

  $start_date = new DateTime($context['form_values']['bat_start_date']);
  $end_date = new DateTime($context['form_values']['bat_end_date']);
  $end_date->sub(new DateInterval('PT1M'));

  if (isset($type_bundle->default_event_value_field_ids[$event_type]) && !empty($type_bundle->default_event_value_field_ids[$event_type])) {
    $event = bat_event_create(array(
      'type' => $event_type,
      'start_date' => $start_date->format('Y-m-d H:i:s'),
      'end_date' => $end_date->format('Y-m-d H:i:s'),
      'uid' => $type->uid,
      'created' => REQUEST_TIME,
    ));

    $event->event_bat_unit_reference['und'][0]['target_id'] = $unit->unit_id;

    $event->event_state_reference['und'][0]['state_id'] = $state['id'];

    $event->save();
  }
}

/**
 * Prepares variables for list of available node type templates.
 *
 * Default template: bat-event-add-list.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - content: An array of content types.
 */
function template_preprocess_bat_event_add_list(&$variables) {
  $variables['types'] = array();
  if (!empty($variables['content'])) {
    foreach ($variables['content'] as $type) {
      $variables['types'][$type->id()] = array(
        'type' => $type->id(),
        'add_link' => \Drupal::l($type->label(), new Url('entity.bat_event.add_form', array('event_type' => $type->id()))),
      );
    }
  }
}

/**
 * @param $event_type
 */
function bat_event_get_states($event_type, $options = array()) {
  return State::loadMultiple();
}

/**
 * Prepares variables for Event templates.
 *
 * Default template: bat-event.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An associative array containing the user information and any
 *   - attributes: HTML attributes for the containing element.
 */
function template_preprocess_bat_event(array &$variables) {
  // Fetch Event Entity Object.
  $event = $variables['elements']['#bat_event'];

  // Helpful $content variable for templates.
  foreach (Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }
}

/**
 * @param $machine_name
 */
function bat_event_load_state_by_machine_name($machine_name) {
  return State::loadbyMachineName($machine_name);
}
