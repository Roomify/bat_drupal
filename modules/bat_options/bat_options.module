<?php

/**
 * @file
 */

define('BAT_OPTIONS_ADD', 'add');
define('BAT_OPTIONS_ADD_DAILY', 'add-daily');
define('BAT_OPTIONS_SUB', 'sub');
define('BAT_OPTIONS_SUB_DAILY', 'sub-daily');
define('BAT_OPTIONS_REPLACE', 'replace');
define('BAT_OPTIONS_INCREASE', 'increase');
define('BAT_OPTIONS_DECREASE', 'decrease');
define('BAT_OPTIONS_OPTIONAL', 'optional');
define('BAT_OPTIONS_MANDATORY', 'mandatory');
define('BAT_OPTIONS_ONREQUEST', 'on_request');

/**
 * Page callback to handle AJAX for removing a bat options item.
 *
 * This is a direct page callback. The actual job of deleting the item is
 * done in the submit handler for the button, so all we really need to
 * do is process the form and then generate output. We generate this
 * output by doing a replace command on the id of the entire form element.
 */
function bat_options_remove_js() {
  // drupal_html_id() very helpfully ensures that all html IDS are unique
  // on a page. Unfortunately what it doesn't realize is that the IDs
  // we are generating are going to replace IDs that already exist, so
  // this actually works against us.
  if (isset($_POST['ajax_html_ids'])) {
    unset($_POST['ajax_html_ids']);
  }

  list($form, $form_state, $form_id, $form_build_id, $commands) = ajax_get_form();
  drupal_process_form($form['#form_id'], $form, $form_state);

  // Get the information on what we're removing.
  $button = $form_state['triggering_element'];
  // Go two levels up in the form, to the whole widget.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -3));
  // Now send back the proper AJAX command to replace it.
  $commands[] = ajax_command_replace('#' . $element['#id'], drupal_render($element));
  $return = array(
    '#type' => 'ajax',
    '#commands' => $commands,
  );

  // Because we're doing this ourselves, messages aren't automatic. We have
  // to add them.
  $messages = theme('status_messages');
  if ($messages) {
    $return['#commands'][] = ajax_command_prepend('#' . $element['#id'], $messages);
  }

  return $return;
}

/**
 * Submit callback to remove an item from the field UI multiple wrapper.
 *
 * When a remove button is submitted, we need to find the item that it
 * referenced and delete it. Since field UI has the deltas as a straight
 * unbroken array key, we have to renumber everything down. Since we do this
 * we *also* need to move all the deltas around in the $form_state['values'],
 * $form_state['input'], and $form_state['field'] so that user changed values
 * follow. This is a bit of a complicated process.
 */
function bat_options_remove_submit($form, &$form_state) {
  $button = $form_state['triggering_element'];
  $delta = $button['#delta'];

  // Where in the form we'll find the parent element.
  $address = array_slice($button['#array_parents'], 0, -2);

  // Go one level up in the form, to the widgets container.
  $parent_element = drupal_array_get_nested_value($form, $address);
  $field_name = $parent_element['#field_name'];
  $langcode = $parent_element['#language'];
  $parents = $parent_element['#field_parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);

  // Go ahead and renumber everything from our delta to the last
  // item down one. This will overwrite the item being removed.
  for ($i = $delta; $i <= $field_state['items_count']; $i++) {
    $old_element_address = array_merge($address, array($i + 1));
    $new_element_address = array_merge($address, array($i));

    $moving_element = drupal_array_get_nested_value($form, $old_element_address);
    $moving_element_value = drupal_array_get_nested_value($form_state['values'], $old_element_address);
    $moving_element_input = drupal_array_get_nested_value($form_state['input'], $old_element_address);
    $moving_element_field = drupal_array_get_nested_value($form_state['field'], $old_element_address);

    // Tell the element where it's being moved to.
    $moving_element['#parents'] = $new_element_address;

    // Move the element around.
    form_set_value($moving_element, $moving_element_value, $form_state);
    drupal_array_set_nested_value($form_state['input'], $moving_element['#parents'], $moving_element_input);
    drupal_array_set_nested_value($form_state['field'], $moving_element['#parents'], $moving_element_field);
  }

  // Then remove the last item. But we must not go negative.
  if ($field_state['items_count'] > 0) {
    $field_state['items_count']--;
  }

  // Fix the weights. Field UI lets the weights be in a range of
  // (-1 * item_count) to (item_count). This means that when we remove one,
  // the range shrinks; weights outside of that range then get set to
  // the first item in the select by the browser, floating them to the top.
  // We use a brute force method because we lost weights on both ends
  // and if the user has moved things around, we have to cascade because
  // if I have items weight weights 3 and 4, and I change 4 to 3 but leave
  // the 3, the order of the two 3s now is undefined and may not match what
  // the user had selected.
  $input = drupal_array_get_nested_value($form_state['input'], $address);
  // Sort by weight
  uasort($input, '_field_sort_items_helper');

  // Reweight everything in the correct order.
  $weight = -1 * $field_state['items_count'];
  foreach ($input as $key => $item) {
    if ($item) {
      $input[$key]['_weight'] = $weight++;
    }
  }

  drupal_array_set_nested_value($form_state['input'], $address, $input);
  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;
}

/**
 * Returns the available price options for booking_unit options field.
 */
function bat_options_price_options() {
  return array(
    BAT_OPTIONS_ADD => t('Add to price'),
    BAT_OPTIONS_ADD_DAILY => t('Add to price per night'),
    BAT_OPTIONS_SUB => t('Subtract from price'),
    BAT_OPTIONS_SUB_DAILY => t('Subtract from price per night'),
    BAT_OPTIONS_REPLACE => t('Replace price'),
    BAT_OPTIONS_INCREASE => t('Increase price by % amount'),
    BAT_OPTIONS_DECREASE => t('Decrease price by % amount'),
  );
}

/**
 * Returns available options given a Bat type.
 *
 * @param BatType $type
 *   The type from which to retrieve options.
 *
 * @return array
 *   The available options for the given type.
 */
function bat_options_get_type_options($type) {
  $options = &drupal_static(__FUNCTION__);

  if (isset($options['types'][$type->type_id])) {
    return $options['types'][$type->type_id];
  }

  $type_options = is_array(field_get_items('bat_type', $type, 'field_addons')) ? field_get_items('bat_type', $type, 'field_addons') : array();
  $options['types'][$type->type_id] = $type_options;

  return $options['types'][$type->type_id];
}

/**
 * Converts option human name to its machine name.
 *
 * @param string $option_name
 *   The human option name.
 * @param string $pattern
 *   The pattern used to convert. By default "/[^a-z0-9_]+/".
 * @param string $replacement
 *   The replacement string. By default "_".
 *
 * @return string
 *   The option machine name.
 */
function bat_options_get_machine_name($option_name, $pattern = '/[^a-z0-9_]+/', $replacement = '_') {
  return preg_replace($pattern, $replacement, drupal_strtolower($option_name));
}

/**
 * Given an option, return a string that explains the operation.
 */
function bat_options_get_operation_label($option) {
  $label = '';

  $currency_setting = commerce_currency_load(commerce_default_currency());
  $currency_symbol = $currency_setting['symbol'];

  switch ($option['operation']) {
    case 'add':
      $label = t('+@amount@currency_symbol to price', array(
        '@amount' => $option['value'],
        '@currency_symbol' => $currency_symbol,
        )
      );
      break;

    case 'add-daily':
      $label = t('+@amount@currency_symbol per night to price', array(
        '@amount' => $option['value'],
        '@currency_symbol' => $currency_symbol,
        )
      );
      break;

    case 'sub-daily':
      $label = t('-@amount@currency_symbol per night from price', array(
        '@amount' => $option['value'],
        '@currency_symbol' => $currency_symbol,
        )
      );
      break;

    case 'replace':
      $label = t('Replace price with @amount@currency_symbol', array(
        '@amount' => $option['value'],
        '@currency_symbol' => $currency_symbol,
        )
      );
      break;

    case 'increase':
      $label = t('Increase price by @amount%', array(
        '@amount' => $option['value'],
        )
      );
      break;

    case 'decrease':
      $label = t('Decrease price by @amount%', array(
        '@amount' => $option['value'],
        )
      );
      break;

    case 'sub':
      $label = t('-@amount@currency_symbol from price', array(
        '@amount' => $option['value'],
        '@currency_symbol' => $currency_symbol,
        )
      );
      break;

  }

  return $label;
}

/**
 * Calculate the price for an option.
 */
function bat_options_get_option_price($booking_price, $option, $quantity, $nights) {
  $price = 0;

  switch ($option['operation']) {
    case BAT_OPTIONS_ADD:
      $price += $option['value'];
      break;

    case BAT_OPTIONS_ADD_DAILY:
      $price += $option['value'] * $nights;
      break;

    case BAT_OPTIONS_SUB:
      $price -= $option['value'];
      break;

    case BAT_OPTIONS_SUB_DAILY:
      $price -= $option['value'] * $nights;
      break;

    case BAT_OPTIONS_REPLACE:
      $price = $option['value'] - ($booking_price / 100);
      break;

    case BAT_OPTIONS_INCREASE:
      $price += $booking_price * $option['value'] / 100;
      break;

    case BAT_OPTIONS_DECREASE:
      $price -= $base_price * $option['value'] / 100;
      break;
  }

  return $price * 100;
}
