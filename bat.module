<?php

/**
 * @file
 * Contains bat.module..
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Url;
use Drupal\Component\Utility\Html;
use Drupal\Core\Form\FormStateInterface;


/**
 * Implements hook_help().
 */
function bat_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the bat module.
    case 'help.page.bat':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('A generalized Booking and Availability Management Framework') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_theme().
 */
function bat_theme() {
  return array(
    'bat_property_add_list' => array(
      'variables' => array('content' => NULL),
    ),
  );
}

/**
 * Implements hook_toolbar().
 */
function bat_toolbar() {
  $items = array();

  $items['bat'] = array(
    '#type' => 'toolbar_item',
    '#attached' => array(
      'library' => array(
        'bat/drupal.bat.toolbar',
      ),
    ),
  );

  return $items;
}

/**
 * Prepares variables for list of available node type templates.
 *
 * Default template: bat-property-add-list.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - content: An array of content types.
 *
 * @see node_add_page()
 */
function template_preprocess_bat_property_add_list(&$variables) {
  $variables['types'] = array();
  if (!empty($variables['content'])) {
    foreach ($variables['content'] as $type) {
      $variables['types'][$type->id()] = array(
        'type' => $type->id(),
        'add_link' => \Drupal::l($type->label(), new Url('entity.property.add_form', array('property_type' => $type->id()))),
      );
    }
  }
}

/**
 * Implements hook_entity_access().
 */
function bat_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
  $rights = &drupal_static(__FUNCTION__, array());

  $entity_type = $entity->getEntityType()->id();

  if (in_array($entity_type, array('unit_type'))) {
    $entity_info = \Drupal::entityManager()->getDefinition($entity_type);

    // $entity may be either an object or a entity type. Since entity types cannot
    // be an integer, use either nid or type as the static cache id.
    $cid = is_object($entity) ? $entity->id() : $entity;

    // If we are creating a new entity make sure we set the type so permissions get
    // applied
    if ($op == 'create' && $cid == '') {
      $cid = $entity->type;
    }

    // If we've already checked access for this node, user and op, return the
    // cached result.
    if (isset($rights[$account->uid][$cid][$op])) {
      if ($rights[$account->uid][$cid][$op]) {
        return AccessResult::allowed();
      }
      else {
        return AccessResult::forbidden();
      }
    }

    // Grant generic administrator level access.
    if ($account->hasPermission('bypass ' . $entity_type . ' entities access')) {
      $rights[$account->uid][$cid][$op] = TRUE;
      return AccessResult::allowed();
    }

    if ($op == 'view') {
      if (isset($entity)) {
        // When trying to figure out access to an entity, query the base table
        // using our access control tag.
        if (!empty($entity_info['access arguments']['access tag']) && module_implements('query_' . $entity_info['access arguments']['access tag'] . '_alter')) {
          $query = db_select($entity_info['base table']);
          $query->addExpression('1');
          $result = (bool) $query
            ->addTag($entity_info['access arguments']['access tag'])
            ->addMetaData('account', $account)
            ->condition($entity_info['entity keys']['id'], $entity->{$entity_info['entity keys']['id']})
            ->range(0, 1)
            ->execute()
            ->fetchField();
          $rights[$account->uid][$cid][$op] = $result;
          return $result;
        }
        else {
          $rights[$account->uid][$cid][$op] = TRUE;
          return AccessResult::allowed();
        }
      }
      else {
        $access = $account->hasPermission('view any ' . $entity_type . ' entity');
        $rights[$account->uid][$cid][$op] = $access;
        
        if ($access) {
          return AccessResult::allowed();
        }
        else {
          return AccessResult::forbidden();
        }
      }
    }
    else { // Non-view operations.
      // First grant access to the entity for the specified operation if no other
      // module denies it and at least one other module says to grant access.
      $access_results = \Drupal::moduleHandler()->invokeAll('bat_entity_access', $op, $entity, $account, $entity_type);

      if (in_array(FALSE, $access_results, TRUE)) {
        $rights[$account->uid][$cid][$op] = FALSE;
        return AccessResult::forbidden();
      }
      elseif (in_array(TRUE, $access_results, TRUE)) {
        $rights[$account->uid][$cid][$op] = TRUE;
        return AccessResult::allowed();
      }

      // Grant access based on entity type and bundle specific permissions with
      // special handling for the create operation since the entity passed in will
      // be initialized without ownership.
      if ($op == 'create') {
        // Assuming an entity was passed in and we know its bundle key, perform
        // the entity type and bundle-level access checks.
        if (isset($entity)) {
          $access = $account->hasPermission('create ' . $entity_type . ' entities') || $account->hasPermission('create ' . $entity_type . ' entities of bundle ' . $entity->bundle());
          $rights[$account->uid][$cid][$op] = $access;

          if ($access) {
            return AccessResult::allowed();
          }
          else {
            return AccessResult::forbidden();
          }
        }
        else {
          // Otherwise perform an entity type-level access check.
          $access = $account->hasPermission('create ' . $entity_type . ' entities');
          $rights[$account->uid][$cid][$op] = $access;

          if ($access) {
            return AccessResult::allowed();
          }
          else {
            return AccessResult::forbidden();
          }
        }
      }
      else {
        // Finally perform checks for the rest of operations. Begin by
        // extracting the bundle name from the entity if available.
        $bundle_name = '';

        if (isset($entity)) {
          $bundle_name = $entity->bundle();
        }

        // For the delete and delete operations, first perform the entity type and
        // bundle-level access check for any entity.
        if ($account->hasPermission($op . ' any ' . $entity_type . ' entity') ||
            $account->hasPermission($op . ' any ' . $entity_type . ' entity of bundle ' . $bundle_name)) {
          $rights[$account->uid][$cid][$op] = TRUE;
          return AccessResult::allowed();
        }

        // Then check an authenticated user's access to delete his own entities.
        if ($account->uid && !empty($entity_info['access arguments']['user key']) && isset($entity->{$entity_info['access arguments']['user key']}) && $entity->{$entity_info['access arguments']['user key']} == $account->uid) {
          if ($account->hasPermission($op . ' own ' . $entity_type . ' entities') ||
              $account->hasPermission($op . ' own ' . $entity_type . ' entities of bundle ' . $bundle_name)) {
            $rights[$account->uid][$cid][$op] = TRUE;
            return AccessResult::allowed();
          }
        }
      }
    }

    return AccessResult::forbidden();
  }
}

/**
 * Return permission names for a given entity type.
 */
function bat_entity_access_permissions($entity_type) {
  $entity_info = \Drupal::entityManager()->getDefinition($entity_type);
  $label = $entity_info->getLabel()->__toString();

  $permissions = array();

  // General 'bypass' permission.
  $permissions['bypass ' . $entity_type . ' entities access'] = array(
    'title' => t('Bypass access to @entity_type', array('@entity_type' => $label)),
    'description' => t('Allows users to perform any action on @entity_type.', array('@entity_type' => $label)),
    'restrict access' => TRUE,
  );

  // Generic create and edit permissions.
  $permissions['create ' . $entity_type . ' entities'] = array(
    'title' => t('Create @entity_type of any type', array('@entity_type' => $label)),
  );
  $permissions['view own ' . $entity_type . ' entities'] = array(
    'title' => t('View own @entity_type of any type', array('@entity_type' => $label)),
  );
  $permissions['view any ' . $entity_type . ' entity'] = array(
    'title' => t('View any @entity_type of any type', array('@entity_type' => $label)),
    'restrict access' => TRUE,
  );
  $permissions['update own ' . $entity_type . ' entities'] = array(
    'title' => t('Edit own @entity_type of any type', array('@entity_type' => $label)),
  );
  $permissions['update any ' . $entity_type . ' entity'] = array(
    'title' => t('Edit any @entity_type of any type', array('@entity_type' => $label)),
    'restrict access' => TRUE,
  );
  $permissions['delete own ' . $entity_type . ' entities'] = array(
    'title' => t('Delete own @entity_type of any type', array('@entity_type' => $label)),
  );
  $permissions['delete any ' . $entity_type . ' entity'] = array(
    'title' => t('Delete any @entity_type of any type', array('@entity_type' => $label)),
    'restrict access' => TRUE,
  );

  // Per-bundle create and edit permissions.
  foreach (entity_get_bundles($entity_type) as $bundle_name => $bundle_info) {
    $permissions['create ' . $entity_type . ' entities of bundle ' . $bundle_name] = array(
      'title' => t('Create %bundle @entity_type', array('@entity_type' => $label, '%bundle' => $bundle_info['label'])),
    );
    $permissions['view own ' . $entity_type . ' entities of bundle ' . $bundle_name] = array(
      'title' => t('View own %bundle @entity_type', array('@entity_type' => $label, '%bundle' => $bundle_info['label'])),
    );
    $permissions['view any ' . $entity_type . ' entity of bundle ' . $bundle_name] = array(
      'title' => t('View any %bundle @entity_type', array('@entity_type' => $label, '%bundle' => $bundle_info['label'])),
      'restrict access' => TRUE,
    );
    $permissions['update own ' . $entity_type . ' entities of bundle ' . $bundle_name] = array(
      'title' => t('Edit own %bundle @entity_type', array('@entity_type' => $label, '%bundle' => $bundle_info['label'])),
    );
    $permissions['update any ' . $entity_type . ' entity of bundle ' . $bundle_name] = array(
      'title' => t('Edit any %bundle @entity_type', array('@entity_type' => $label, '%bundle' => $bundle_info['label'])),
      'restrict access' => TRUE,
    );
    $permissions['delete own ' . $entity_type . ' entities of bundle ' . $bundle_name] = array(
      'title' => t('Delete own %bundle @entity_type', array('@entity_type' => $label, '%bundle' => $bundle_info['label'])),
    );
    $permissions['delete any ' . $entity_type . ' entity of bundle ' . $bundle_name] = array(
      'title' => t('Delete any %bundle @entity_type', array('@entity_type' => $label, '%bundle' => $bundle_info['label'])),
      'restrict access' => TRUE,
    );
  }

  return $permissions;
}

/**
 * Implements hook_query_alter().
 *
 * Enforces access control for bat units during database queries.
 */
function bat_entity_access_query_alter($query, $entity_type, $base_table = NULL, $account = NULL, $op = 'view') {
  global $user;

  // Get the Drupal user account from the query if available, or
  // default to the logged in user if not.
  if (!isset($account) && !$account = $query->getMetaData('account')) {
    $account = $user;
  }

  // Do not apply any conditions for users with administrative view permissions.
  if ($account->hasPermission('bypass ' . $entity_type . ' access') ||
      $account->hasPermission($op . ' any ' . $entity_type . ' entity')) {
    return;
  }

  // Get the entity type info array for the current access check and prepare a
  // conditions object.
  $entity_info = \Drupal::entityManager()->getDefinition($entity_type);

  // If a base table wasn't specified, attempt to read it from the query if
  // available, look for a table in the query's tables array that matches the
  // base table of the given entity type, or just default to the first table.
  if (!isset($base_table) && !$base_table = $query->getMetaData('base_table')) {
    // Initialize the base table to the first table in the array. If a table can
    // not be found that matches the entity type's base table, this will result
    // in an invalid query if the first table is not the table we expect,
    // forcing the caller to actually properly pass a base table in that case.
    $tables = $query->getTables();
    reset($tables);
    $base_table = key($tables);

    foreach ($tables as $table_info) {
      if (!($table_info instanceof SelectQueryInterface)) {
        // If this table matches the entity type's base table, use its table
        // alias as the base table for the purposes of bundle and ownership
        // access checks.
        if ($table_info['table'] == $entity_info['base table']) {
          $base_table = $table_info['alias'];
        }
      }
    }
  }

  // Prepare an OR container for conditions. Conditions will be added that seek
  // to grant access, meaning any particular type of permission check may grant
  // access even if none of the others apply. At the end of this function, if no
  // conditions have been added to the array, a condition will be added that
  // always returns FALSE (1 = 0).
  $conditions = db_or();

  // Perform bundle specific permission checks for the specified entity type.
  // In the event that the user has permission to view every bundle of the given
  // entity type, $really_restricted will remain FALSE, indicating that it is
  // safe to exit this function without applying any additional conditions. If
  // the user only had such permission for a subset of the defined bundles,
  // conditions representing those access checks would still be added.
  $really_restricted = FALSE;

  // Loop over every possible bundle for the given entity type.
  foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
    // If the user has access to operation entities of the current bundle...
    if ($account->hasPermission($op . ' any ' . $entity_type . ' entity of bundle ' . $bundle_name)) {
      // Add a condition granting access if the entity specified by the view
      // query is of the same bundle.
      $conditions->condition($base_table . '.' . $entity_info['entity keys']['bundle'], $bundle_name);
    }
    elseif ($account->uid && !empty($entity_info['access arguments']['user key']) &&
            $account->hasPermission($op . ' own ' . $entity_type . ' entities of bundle ' . $bundle_name)) {
      // Add an AND condition group that grants access if the entity specified
      // by the view query matches the same bundle and belongs to the user.
      $conditions->condition(db_and()
        ->condition($base_table . '.' . $entity_info['entity keys']['bundle'], $bundle_name)
        ->condition($base_table . '.' . $entity_info['access arguments']['user key'], $account->uid)
      );
    }
  }

  // If the given entity type has a user ownership key...
  if (!empty($entity_info['access arguments']['user key'])) {
    // Perform 'operation own' access control for the entity in the query if the
    // user is authenticated.
    if ($account->uid && $account->hasPermission($op . ' own ' . $entity_type . ' entities')) {
      $conditions->condition($base_table . '.' . $entity_info['access arguments']['user key'], $account->uid);
    }
  }

  // Prepare an array of condition alter hooks to invoke and an array of context
  // data for the current query.
  $hooks = array(
    'bat_entity_access_' . $op . '_condition_' . $entity_type,
    'bat_entity_access_' . $op . '_condition',
  );

  $context = array(
    'account' => $account,
    'entity_type' => $entity_type,
    'base_table' => $base_table,
  );

  // Allow other modules to add conditions to the array as necessary.
  \Drupal::moduleHandler()->alter($hooks, $conditions, $context);

  // If we have more than one condition based on the entity access permissions
  // and any hook implementations...
  if (count($conditions)) {
    // Add the conditions to the query.
    $query->condition($conditions);
  }
  else {
    // Otherwise, since we don't have any possible conditions to match against,
    // we falsify this query. View checks are access grants, not access denials.
    $query->where('1 = 0');
  }
}

/**
 * Utility function to create two related datepickers.
 *
 * We have a few forms that need a start and end date field
 * and we need to apply the same javascript to these forms in order to enforce
 * specific consistent behaviours and group the form elements and javascript
 * injection in one place.
 *
 * @param int $year
 * @param int $month
 *
 * @return array
 *   The array holding the field definitions
 */
function bat_date_range_fields($year = NULL, $month = NULL, $granularity = 'bat_hourly') {
  $date_range_fields = array();

  $config = \Drupal::config('bat.settings');

  // Create unique ids and selectors for each datepicker.
  $start_date_id = Html::getUniqueId('datepicker-start-date');
  $start_date_selector = '#' . $start_date_id . ' .form-text';

  $end_date_id = Html::getUniqueId('datepicker-end-date');
  $end_date_selector = '#' . $start_date_id . ' .form-text';

  // Specify the default datepicker parameters (see date_popup_element_info())
  $datepicker_options = array(
    //'dateFormat' => date_popup_format_to_popup($config->get('bat_daily_date_format')),
    // Limit bookings to X days in advance according to the
    // chosen configuration in your BAT installation.
    // Defaults to the current day.
    'minDate' => '+' . $config->get('bat_event_start_date') . 'd',
  );

  if ($year && $month) {
    // Calculate min and max dates of the specified year/month.
    $date = new DateTime();
    $date->setDate($year, $month, 01);
    $min_date = $date->format($config->get('bat_daily_date_format'));
    $date->modify('last day of this month');
    $max_date = $date->format($config->get('bat_daily_date_format'));
    $datepicker_options += array(
      'minDate' => $min_date,
      'maxDate' => $max_date,
      'defaultDate' => $min_date,
      'numberOfMonths' => 1,
    );
  }
  else {
    $datepicker_options += array(
      'minDate' => '+' . $config->get('bat_event_start_date') . 'd',
    );
  }

  $date_range_fields['bat_start_date'] = array(
    '#prefix' => '<div class="form-wrapper bat-date-range"><div class="start-date" id="' . $start_date_id . '">',
    '#suffix' => '</div>',
    '#type' => 'date',
    '#title' => t('Event Start'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => $config->get('bat_daily_date_format'),
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    // Default parameters defined above, with an additional parameter
    // linking to the jQuery selector for the end datepicker.
    '#datepicker_options' => array_merge($datepicker_options, array('endDateSelector' => $end_date_selector)),
    '#required' => TRUE,
  );

  $date_range_fields['bat_end_date'] = array(
    '#prefix' => '<div class="end-date" id="' . $end_date_id . '">',
    '#suffix' => '</div></div>',
    '#type' => 'date',
    '#title' => t('Event End'),
    '#date_type' => DATE_DATETIME,
    '#date_format' => $config->get('bat_daily_date_format'),
    '#date_increment' => 1,
    '#date_year_range' => '-1:+3',
    // Default parameters defined above, with an additional parameter
    // parameter linking to the jQuery selector for the start datepicker.
    '#datepicker_options' => array_merge($datepicker_options, array('startDateSelector' => $start_date_selector)),
    '#required' => TRUE,
    '#attached' => array('library' => array('bat/bat_date_range')),
  );

  return $date_range_fields;
}

/**
 * Given a form state array, locate the start/end dates in the input array
 * and instantiate and return DateTime objects.
 */
function bat_form_input_get_start_end_dates(FormStateInterface $form_state) {
  // If form_state['values']['bat_X_date'] is not set, it is an empty array.
  // In this case, we need to check and set values so that
  // _constructor below will not fail.
  if (is_array($form_state['values']['bat_start_date'])) {
    if ($form_state['values']['bat_start_date']['date'] == '') {
      $start = new DateTime();
    }
    else {
      $start = new DateTime($form_state['values']['bat_start_date']['date'] . ' ' . $form_state['values']['bat_start_date']['time']);
    }
  }
  else {
    $start = new DateTime($form_state['values']['bat_start_date']);
  }

  if (is_array($form_state['values']['bat_end_date'])) {
    if ($form_state['values']['bat_end_date']['date'] == '') {
      $end = new DateTime();
    }
    else {
      $end = new DateTime($form_state['values']['bat_end_date']['date'] . ' ' . $form_state['values']['bat_end_date']['time']);
    }
  }
  else {
    $end = new DateTime($form_state['values']['bat_end_date']);
  }

  return array($start, $end);
}

/**
 * Given a form state array, locate the start/end dates in the
 * values array and instantiate and return DateTime objects.
 */
function bat_form_values_get_start_end_dates($form_state) {
  // Date values have a format of year-month-day.
  // This is one of the default expected formats, so there
  // is no need to explicitly define the format.
  // (see http://www.php.net/manual/en/datetime.formats.date.php)
  $start_date = $form_state['values']['bat_start_date'];
  $end_date = $form_state['values']['bat_end_date'];

  // If the input format is numeric we assume that is a Unix timestamp.
  if (is_numeric($start_date) && is_numeric($end_date)) {
    // The @ lets the DateTime class know that the date is
    // formatted as a Unix timestamp.
    $start_date = '@' . $start_date;
    $end_date = '@' . $end_date;
  }

  $start = new DateTime($start_date);
  $end = new DateTime($end_date);

  return array($start, $end);
}

/**
 * Validation callback that can be reused in all forms that need to
 * validate dates.
 *
 * The end date must be greater than start date.
 */
function bat_form_start_end_dates_validate($form, FormStateInterface $form_state) {
  list($start_date, $end_date) = bat_form_input_get_start_end_dates($form_state);

  // Fail validation if no dates are provided.
  if (empty($start_date) || empty($end_date)) {
    form_set_error('date_range', t('Please choose dates.'));
    return;
  }

  // Check date validity.
  $errors = bat_check_dates_validity($start_date, $end_date);

  // For some forms we need to ensure that the selected date matches with current values.
  if (isset($form_state['values']['curr_month']) && isset($form_state['values']['curr_year'])) {
    $curr_month = $form_state['values']['curr_month'];
    $curr_year = $form_state['values']['curr_year'];
    if ($start_date->format('n') != $curr_month ||
        $end_date->format('n') != $curr_month   ||
        $start_date->format('Y') != $curr_year  ||
        $end_date->format('Y') != $curr_year) {
      $errors[] = t('Both the start and end date must be within the current month.');
    }
  }

  // When there are multiple errors for the same form element, Drupal only
  // displays the first. Here we concatenate all errors so that they will all
  // be displayed.
  if ($errors) {
    $error_msg = implode(' ', $errors);
    form_set_error('date_range', $error_msg);
  }
}

/**
 * Checks the logical validity of date values.
 *
 * @param DateTime $start_date
 *   The start date
 * @param DateTime $end_date
 *   The end date
 *
 * @return array
 *   An array with error messages.
 */
function bat_check_dates_validity(DateTime $start_date, DateTime $end_date) {
  $errors = array();

  // The end date must be greater or equal than start date.
  if ($end_date < $start_date) {
    $errors[] = t('End date must be on or after the start date.');
  }

  return $errors;
}
